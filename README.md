Please refer to the `Code_new/` subdir for the current codebase. 
#Pipeline:
- Train the NN in MATLAB using my `train_deepnet_bayesopt.m` script that calls `deepnetObjectiveFcn()` which utilizes MATLAB's `trainNetwork()` function for training, the former script also performs Bayesian optimization for hyeperparameter tuning using MATLAB's `bayesopt()`. 
- The best trained model along with a minimum classification error plot will get saved in the `training_results` subdir as `trained_deepnet_model.mat`.
- This model can be tested for inference using the `test_deepnet_model.m` script. The testing results get saved in the `testing_results` subir. This includes a confusion matrix and ROC for the test.
- Next, to move into the broader pipeline for app dev, we need the model in a more standard format. First, use the `mat_to_tf.m` script.
- The conversion goes like this: `.mat --> dlnetwork --> TF --> SavedModel --> TFlite`. Converting the `Layers` array from the `.mat` to a `dlnetwork` requires it to have no output layers, thus the script removes it with `lgraph = removeLayers(lgraph, 'classoutput');`.
- The resulting `myNN` subdir from the previous step will have our TF model. Next, to get a SavedModel format from this, use the `smart_chair_test.ipynb` notebook.
- `my_saved_NN` is in SavedModel format. Finally the notebook then converts it to a `.TFlite` file and saves it too (as `model.tflite`).  

The `__init__.py` generated by `exportNetworkToTensorFlow()` in MATLAB gives errors when actually trying to use that model further in a python pipeline.
To fix this, make a few changes in the file:

Replace
```
import myNN.model
import os
```
with
```
from . import model
from .model import ZScoreLayer
import os
```

And inside the `loadWeights()` method:

Replace
```
# Assign the weights into the layer
for w in range(numVars):
    if debug:
        print("Copying variable of shape:")
        print(weightList[w].shape)
    layer.variables[w].assign(weightList[w])
    if debug:
        print("Assignment successful.")
        print("Set variable value:")
        print(layer.variables[w])
```
with
```
# Assign weights into the layer
if isinstance(layer, ZScoreLayer):
    if debug:
        print("Assigning to ZScoreLayer attributes...")
    if numVars != 2:
        raise ValueError(f"Expected 2 variables for ZScoreLayer, got {numVars}")
    layer.mean.assign(weightList[0])
    layer.std.assign(weightList[1])
    if debug:
        print("Assignment successful.")
        print("Set mean:", layer.mean)
        print("Set std:", layer.std)
else:
    for w in range(numVars):
        if debug:
            print("Copying variable of shape:")
            print(weightList[w].shape)
        layer.variables[w].assign(weightList[w])
        if debug:
            print("Assignment successful.")
            print("Set variable value:")
            print(layer.variables[w])
```
